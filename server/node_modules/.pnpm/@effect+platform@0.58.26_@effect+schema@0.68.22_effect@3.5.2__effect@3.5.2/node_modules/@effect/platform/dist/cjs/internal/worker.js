"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeSerialized = exports.makePoolSerializedLayer = exports.makePoolSerialized = exports.makePoolLayer = exports.makePool = exports.makeManager = exports.layerSpawner = exports.layerManager = exports.defaultQueue = exports.WorkerManagerTypeId = exports.WorkerManager = exports.Spawner = exports.PlatformWorkerTypeId = exports.PlatformWorker = void 0;
var Schema = _interopRequireWildcard(require("@effect/schema/Schema"));
var Serializable = _interopRequireWildcard(require("@effect/schema/Serializable"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Channel = _interopRequireWildcard(require("effect/Channel"));
var Chunk = _interopRequireWildcard(require("effect/Chunk"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var Fiber = _interopRequireWildcard(require("effect/Fiber"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Pool = _interopRequireWildcard(require("effect/Pool"));
var Queue = _interopRequireWildcard(require("effect/Queue"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var Tracer = _interopRequireWildcard(require("effect/Tracer"));
var Transferable = _interopRequireWildcard(require("../Transferable.js"));
var _WorkerError = require("../WorkerError.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/** @internal */
const defaultQueue = () => Effect.map(Queue.unbounded(), queue => ({
  offer: (id, item, span) => Queue.offer(queue, [id, item, span]),
  take: Queue.take(queue),
  shutdown: Queue.shutdown(queue)
}));
/** @internal */
exports.defaultQueue = defaultQueue;
const PlatformWorkerTypeId = exports.PlatformWorkerTypeId = /*#__PURE__*/Symbol.for("@effect/platform/Worker/PlatformWorker");
/** @internal */
const PlatformWorker = exports.PlatformWorker = /*#__PURE__*/Context.GenericTag("@effect/platform/Worker/PlatformWorker");
/** @internal */
const WorkerManagerTypeId = exports.WorkerManagerTypeId = /*#__PURE__*/Symbol.for("@effect/platform/Worker/WorkerManager");
/** @internal */
const WorkerManager = exports.WorkerManager = /*#__PURE__*/Context.GenericTag("@effect/platform/Worker/WorkerManager");
/** @internal */
const Spawner = exports.Spawner = /*#__PURE__*/Context.GenericTag("@effect/platform/Worker/Spawner");
/** @internal */
const makeManager = exports.makeManager = /*#__PURE__*/Effect.gen(function* () {
  const platform = yield* PlatformWorker;
  let idCounter = 0;
  return WorkerManager.of({
    [WorkerManagerTypeId]: WorkerManagerTypeId,
    spawn({
      encode,
      initialMessage,
      queue,
      transfers = _ => []
    }) {
      return Effect.gen(function* (_) {
        const spawn = yield* _(Spawner);
        const id = idCounter++;
        let requestIdCounter = 0;
        const requestMap = new Map();
        const sendQueue = yield* Effect.acquireRelease(Queue.unbounded(), Queue.shutdown);
        const collector = Transferable.unsafeMakeCollector();
        const wrappedEncode = encode ? message => Effect.zipRight(collector.clear, Effect.provideService(encode(message), Transferable.Collector, collector)) : Effect.succeed;
        const outbound = queue ?? (yield* defaultQueue());
        yield* Effect.addFinalizer(() => outbound.shutdown);
        yield* Effect.gen(function* () {
          const readyLatch = yield* Deferred.make();
          const backing = yield* platform.spawn(spawn(id));
          const send = (0, _Function.pipe)(sendQueue.take, Effect.flatMap(([message, transfers]) => backing.send(message, transfers)), Effect.forever);
          const take = (0, _Function.pipe)(Queue.take(backing.queue), Effect.flatMap(msg => {
            if (msg[0] === 0) {
              return Deferred.complete(readyLatch, Effect.void);
            }
            return handleMessage(msg[1]);
          }), Effect.forever);
          return yield* Effect.all([Fiber.join(backing.fiber), Effect.zipRight(Deferred.await(readyLatch), send), take], {
            concurrency: "unbounded"
          });
        }).pipe(Effect.scoped, Effect.onError(cause => Effect.forEach(requestMap.values(), ([queue]) => Queue.offer(queue, Exit.failCause(cause)))), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
          package: "@effect/platform",
          module: "Worker"
        }), Effect.interruptible, Effect.forkScoped);
        yield* Effect.addFinalizer(() => Effect.zipRight(Effect.forEach(requestMap.values(), ([queue]) => Queue.offer(queue, Exit.failCause(Cause.empty)), {
          discard: true
        }), Effect.sync(() => requestMap.clear())));
        const handleMessage = response => Effect.suspend(() => {
          const queue = requestMap.get(response[0]);
          if (!queue) return Effect.void;
          switch (response[1]) {
            // data
            case 0:
              {
                return Queue.offer(queue[0], Exit.succeed(response[2]));
              }
            // end
            case 1:
              {
                return response.length === 2 ? Queue.offer(queue[0], Exit.failCause(Cause.empty)) : Effect.zipRight(Queue.offer(queue[0], Exit.succeed(response[2])), Queue.offer(queue[0], Exit.failCause(Cause.empty)));
              }
            // error / defect
            case 2:
            case 3:
              {
                return Queue.offer(queue[0], response[1] === 2 ? Exit.fail(response[2]) : Exit.failCause(_WorkerError.WorkerError.decodeCause(response[2])));
              }
          }
        });
        const executeAcquire = request => Effect.tap(Effect.all([Effect.sync(() => requestIdCounter++), Queue.unbounded(), Deferred.make(), Effect.map(Effect.serviceOption(Tracer.ParentSpan), Option.filter(span => span._tag === "Span"))]), ([id, queue, deferred, span]) => Effect.suspend(() => {
          requestMap.set(id, [queue, deferred]);
          return outbound.offer(id, request, span);
        }));
        const executeRelease = ([id,, deferred], exit) => {
          const release = Effect.zipRight(Deferred.complete(deferred, Effect.void), Effect.sync(() => requestMap.delete(id)));
          return Exit.isFailure(exit) ? Effect.zipRight(sendQueue.offer([[id, 1]]), release) : release;
        };
        const execute = request => Stream.flatMap(Stream.acquireRelease(executeAcquire(request), executeRelease), ([, queue]) => {
          const loop = Channel.flatMap(Queue.take(queue), Exit.match({
            onFailure: cause => Cause.isEmpty(cause) ? Channel.void : Channel.failCause(cause),
            onSuccess: value => Channel.flatMap(Channel.write(Chunk.unsafeFromArray(value)), () => loop)
          }));
          return Stream.fromChannel(loop);
        });
        const executeEffect = request => Effect.acquireUseRelease(executeAcquire(request), ([, queue]) => Effect.flatMap(Queue.take(queue), Exit.map(Arr.unsafeGet(0))), executeRelease);
        yield* outbound.take.pipe(Effect.flatMap(([id, request, span]) => Effect.fork(Effect.suspend(() => {
          const result = requestMap.get(id);
          if (!result) return Effect.void;
          const transferables = transfers(request);
          const spanTuple = Option.getOrUndefined(Option.map(span, span => [span.traceId, span.spanId, span.sampled]));
          return (0, _Function.pipe)(Effect.flatMap(wrappedEncode(request), payload => sendQueue.offer([[id, 0, payload, spanTuple], [...transferables, ...collector.unsafeRead()]])), Effect.catchAllCause(cause => Queue.offer(result[0], Exit.failCause(cause))), Effect.zipRight(Deferred.await(result[1])));
        }))), Effect.forever, Effect.forkScoped, Effect.interruptible);
        if (initialMessage) {
          yield* Effect.sync(initialMessage).pipe(Effect.flatMap(executeEffect), Effect.mapError(error => new _WorkerError.WorkerError({
            reason: "spawn",
            error
          })));
        }
        return {
          id,
          execute,
          executeEffect
        };
      }).pipe(Effect.parallelFinalizers);
    }
  });
});
/** @internal */
const layerManager = exports.layerManager = /*#__PURE__*/Layer.effect(WorkerManager, makeManager);
/** @internal */
const makePool = options => Effect.gen(function* () {
  const manager = yield* WorkerManager;
  const workers = new Set();
  const acquire = (0, _Function.pipe)(manager.spawn(options), Effect.tap(worker => Effect.sync(() => workers.add(worker))), Effect.tap(worker => Effect.addFinalizer(() => Effect.sync(() => workers.delete(worker)))), options.onCreate ? Effect.tap(options.onCreate) : _Function.identity);
  const backing = "minSize" in options ? yield* Pool.makeWithTTL({
    acquire,
    min: options.minSize,
    max: options.maxSize,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization,
    timeToLive: options.timeToLive
  }) : yield* Pool.make({
    acquire,
    size: options.size,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization
  });
  const pool = {
    backing,
    broadcast: message => Effect.forEach(workers, worker => worker.executeEffect(message), {
      concurrency: "unbounded",
      discard: true
    }),
    execute: message => Stream.unwrapScoped(Effect.map(backing.get, worker => worker.execute(message))),
    executeEffect: message => Effect.scoped(Effect.flatMap(backing.get, worker => worker.executeEffect(message)))
  };
  // report any spawn errors
  yield* Effect.scoped(backing.get);
  return pool;
});
/** @internal */
exports.makePool = makePool;
const makePoolLayer = (tag, options) => Layer.scoped(tag, makePool(options));
/** @internal */
exports.makePoolLayer = makePoolLayer;
const makeSerialized = options => Effect.gen(function* () {
  const manager = yield* WorkerManager;
  const backing = yield* manager.spawn({
    ...options,
    encode(message) {
      return Effect.mapError(Serializable.serialize(message), error => new _WorkerError.WorkerError({
        reason: "encode",
        error
      }));
    }
  });
  const execute = message => {
    const parseSuccess = Schema.decode(Serializable.successSchema(message));
    const parseFailure = Schema.decode(Serializable.failureSchema(message));
    return (0, _Function.pipe)(backing.execute(message), Stream.catchAll(error => Effect.flatMap(parseFailure(error), Effect.fail)), Stream.mapEffect(parseSuccess));
  };
  const executeEffect = message => {
    const parseSuccess = Schema.decode(Serializable.successSchema(message));
    const parseFailure = Schema.decode(Serializable.failureSchema(message));
    return Effect.matchEffect(backing.executeEffect(message), {
      onFailure: error => Effect.flatMap(parseFailure(error), Effect.fail),
      onSuccess: parseSuccess
    });
  };
  return (0, _Function.identity)({
    id: backing.id,
    execute: execute,
    executeEffect: executeEffect
  });
});
/** @internal */
exports.makeSerialized = makeSerialized;
const makePoolSerialized = options => Effect.gen(function* () {
  const manager = yield* WorkerManager;
  const workers = new Set();
  const acquire = (0, _Function.pipe)(makeSerialized(options), Effect.tap(worker => Effect.sync(() => workers.add(worker))), Effect.tap(worker => Effect.addFinalizer(() => Effect.sync(() => workers.delete(worker)))), options.onCreate ? Effect.tap(options.onCreate) : _Function.identity, Effect.provideService(WorkerManager, manager));
  const backing = yield* "timeToLive" in options ? Pool.makeWithTTL({
    acquire,
    min: options.minSize,
    max: options.maxSize,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization,
    timeToLive: options.timeToLive
  }) : Pool.make({
    acquire,
    size: options.size,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization
  });
  const pool = {
    backing,
    broadcast: message => Effect.forEach(workers, worker => worker.executeEffect(message), {
      concurrency: "unbounded",
      discard: true
    }),
    execute: message => Stream.unwrapScoped(Effect.map(backing.get, worker => worker.execute(message))),
    executeEffect: message => Effect.scoped(Effect.flatMap(backing.get, worker => worker.executeEffect(message)))
  };
  // report any spawn errors
  yield* Effect.scoped(backing.get);
  return pool;
});
/** @internal */
exports.makePoolSerialized = makePoolSerialized;
const makePoolSerializedLayer = (tag, options) => Layer.scoped(tag, makePoolSerialized(options));
/** @internal */
exports.makePoolSerializedLayer = makePoolSerializedLayer;
const layerSpawner = spawner => Layer.succeed(Spawner, spawner);
exports.layerSpawner = layerSpawner;
//# sourceMappingURL=worker.js.map