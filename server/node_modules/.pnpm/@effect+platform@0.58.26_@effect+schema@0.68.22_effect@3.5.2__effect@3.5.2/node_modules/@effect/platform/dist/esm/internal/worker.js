import * as Schema from "@effect/schema/Schema";
import * as Serializable from "@effect/schema/Serializable";
import * as Arr from "effect/Array";
import * as Cause from "effect/Cause";
import * as Channel from "effect/Channel";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import * as Deferred from "effect/Deferred";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Fiber from "effect/Fiber";
import { identity, pipe } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Pool from "effect/Pool";
import * as Queue from "effect/Queue";
import * as Schedule from "effect/Schedule";
import * as Stream from "effect/Stream";
import * as Tracer from "effect/Tracer";
import * as Transferable from "../Transferable.js";
import { WorkerError } from "../WorkerError.js";
/** @internal */
export const defaultQueue = () => Effect.map(Queue.unbounded(), queue => ({
  offer: (id, item, span) => Queue.offer(queue, [id, item, span]),
  take: Queue.take(queue),
  shutdown: Queue.shutdown(queue)
}));
/** @internal */
export const PlatformWorkerTypeId = /*#__PURE__*/Symbol.for("@effect/platform/Worker/PlatformWorker");
/** @internal */
export const PlatformWorker = /*#__PURE__*/Context.GenericTag("@effect/platform/Worker/PlatformWorker");
/** @internal */
export const WorkerManagerTypeId = /*#__PURE__*/Symbol.for("@effect/platform/Worker/WorkerManager");
/** @internal */
export const WorkerManager = /*#__PURE__*/Context.GenericTag("@effect/platform/Worker/WorkerManager");
/** @internal */
export const Spawner = /*#__PURE__*/Context.GenericTag("@effect/platform/Worker/Spawner");
/** @internal */
export const makeManager = /*#__PURE__*/Effect.gen(function* () {
  const platform = yield* PlatformWorker;
  let idCounter = 0;
  return WorkerManager.of({
    [WorkerManagerTypeId]: WorkerManagerTypeId,
    spawn({
      encode,
      initialMessage,
      queue,
      transfers = _ => []
    }) {
      return Effect.gen(function* (_) {
        const spawn = yield* _(Spawner);
        const id = idCounter++;
        let requestIdCounter = 0;
        const requestMap = new Map();
        const sendQueue = yield* Effect.acquireRelease(Queue.unbounded(), Queue.shutdown);
        const collector = Transferable.unsafeMakeCollector();
        const wrappedEncode = encode ? message => Effect.zipRight(collector.clear, Effect.provideService(encode(message), Transferable.Collector, collector)) : Effect.succeed;
        const outbound = queue ?? (yield* defaultQueue());
        yield* Effect.addFinalizer(() => outbound.shutdown);
        yield* Effect.gen(function* () {
          const readyLatch = yield* Deferred.make();
          const backing = yield* platform.spawn(spawn(id));
          const send = pipe(sendQueue.take, Effect.flatMap(([message, transfers]) => backing.send(message, transfers)), Effect.forever);
          const take = pipe(Queue.take(backing.queue), Effect.flatMap(msg => {
            if (msg[0] === 0) {
              return Deferred.complete(readyLatch, Effect.void);
            }
            return handleMessage(msg[1]);
          }), Effect.forever);
          return yield* Effect.all([Fiber.join(backing.fiber), Effect.zipRight(Deferred.await(readyLatch), send), take], {
            concurrency: "unbounded"
          });
        }).pipe(Effect.scoped, Effect.onError(cause => Effect.forEach(requestMap.values(), ([queue]) => Queue.offer(queue, Exit.failCause(cause)))), Effect.retry(Schedule.spaced(1000)), Effect.annotateLogs({
          package: "@effect/platform",
          module: "Worker"
        }), Effect.interruptible, Effect.forkScoped);
        yield* Effect.addFinalizer(() => Effect.zipRight(Effect.forEach(requestMap.values(), ([queue]) => Queue.offer(queue, Exit.failCause(Cause.empty)), {
          discard: true
        }), Effect.sync(() => requestMap.clear())));
        const handleMessage = response => Effect.suspend(() => {
          const queue = requestMap.get(response[0]);
          if (!queue) return Effect.void;
          switch (response[1]) {
            // data
            case 0:
              {
                return Queue.offer(queue[0], Exit.succeed(response[2]));
              }
            // end
            case 1:
              {
                return response.length === 2 ? Queue.offer(queue[0], Exit.failCause(Cause.empty)) : Effect.zipRight(Queue.offer(queue[0], Exit.succeed(response[2])), Queue.offer(queue[0], Exit.failCause(Cause.empty)));
              }
            // error / defect
            case 2:
            case 3:
              {
                return Queue.offer(queue[0], response[1] === 2 ? Exit.fail(response[2]) : Exit.failCause(WorkerError.decodeCause(response[2])));
              }
          }
        });
        const executeAcquire = request => Effect.tap(Effect.all([Effect.sync(() => requestIdCounter++), Queue.unbounded(), Deferred.make(), Effect.map(Effect.serviceOption(Tracer.ParentSpan), Option.filter(span => span._tag === "Span"))]), ([id, queue, deferred, span]) => Effect.suspend(() => {
          requestMap.set(id, [queue, deferred]);
          return outbound.offer(id, request, span);
        }));
        const executeRelease = ([id,, deferred], exit) => {
          const release = Effect.zipRight(Deferred.complete(deferred, Effect.void), Effect.sync(() => requestMap.delete(id)));
          return Exit.isFailure(exit) ? Effect.zipRight(sendQueue.offer([[id, 1]]), release) : release;
        };
        const execute = request => Stream.flatMap(Stream.acquireRelease(executeAcquire(request), executeRelease), ([, queue]) => {
          const loop = Channel.flatMap(Queue.take(queue), Exit.match({
            onFailure: cause => Cause.isEmpty(cause) ? Channel.void : Channel.failCause(cause),
            onSuccess: value => Channel.flatMap(Channel.write(Chunk.unsafeFromArray(value)), () => loop)
          }));
          return Stream.fromChannel(loop);
        });
        const executeEffect = request => Effect.acquireUseRelease(executeAcquire(request), ([, queue]) => Effect.flatMap(Queue.take(queue), Exit.map(Arr.unsafeGet(0))), executeRelease);
        yield* outbound.take.pipe(Effect.flatMap(([id, request, span]) => Effect.fork(Effect.suspend(() => {
          const result = requestMap.get(id);
          if (!result) return Effect.void;
          const transferables = transfers(request);
          const spanTuple = Option.getOrUndefined(Option.map(span, span => [span.traceId, span.spanId, span.sampled]));
          return pipe(Effect.flatMap(wrappedEncode(request), payload => sendQueue.offer([[id, 0, payload, spanTuple], [...transferables, ...collector.unsafeRead()]])), Effect.catchAllCause(cause => Queue.offer(result[0], Exit.failCause(cause))), Effect.zipRight(Deferred.await(result[1])));
        }))), Effect.forever, Effect.forkScoped, Effect.interruptible);
        if (initialMessage) {
          yield* Effect.sync(initialMessage).pipe(Effect.flatMap(executeEffect), Effect.mapError(error => new WorkerError({
            reason: "spawn",
            error
          })));
        }
        return {
          id,
          execute,
          executeEffect
        };
      }).pipe(Effect.parallelFinalizers);
    }
  });
});
/** @internal */
export const layerManager = /*#__PURE__*/Layer.effect(WorkerManager, makeManager);
/** @internal */
export const makePool = options => Effect.gen(function* () {
  const manager = yield* WorkerManager;
  const workers = new Set();
  const acquire = pipe(manager.spawn(options), Effect.tap(worker => Effect.sync(() => workers.add(worker))), Effect.tap(worker => Effect.addFinalizer(() => Effect.sync(() => workers.delete(worker)))), options.onCreate ? Effect.tap(options.onCreate) : identity);
  const backing = "minSize" in options ? yield* Pool.makeWithTTL({
    acquire,
    min: options.minSize,
    max: options.maxSize,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization,
    timeToLive: options.timeToLive
  }) : yield* Pool.make({
    acquire,
    size: options.size,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization
  });
  const pool = {
    backing,
    broadcast: message => Effect.forEach(workers, worker => worker.executeEffect(message), {
      concurrency: "unbounded",
      discard: true
    }),
    execute: message => Stream.unwrapScoped(Effect.map(backing.get, worker => worker.execute(message))),
    executeEffect: message => Effect.scoped(Effect.flatMap(backing.get, worker => worker.executeEffect(message)))
  };
  // report any spawn errors
  yield* Effect.scoped(backing.get);
  return pool;
});
/** @internal */
export const makePoolLayer = (tag, options) => Layer.scoped(tag, makePool(options));
/** @internal */
export const makeSerialized = options => Effect.gen(function* () {
  const manager = yield* WorkerManager;
  const backing = yield* manager.spawn({
    ...options,
    encode(message) {
      return Effect.mapError(Serializable.serialize(message), error => new WorkerError({
        reason: "encode",
        error
      }));
    }
  });
  const execute = message => {
    const parseSuccess = Schema.decode(Serializable.successSchema(message));
    const parseFailure = Schema.decode(Serializable.failureSchema(message));
    return pipe(backing.execute(message), Stream.catchAll(error => Effect.flatMap(parseFailure(error), Effect.fail)), Stream.mapEffect(parseSuccess));
  };
  const executeEffect = message => {
    const parseSuccess = Schema.decode(Serializable.successSchema(message));
    const parseFailure = Schema.decode(Serializable.failureSchema(message));
    return Effect.matchEffect(backing.executeEffect(message), {
      onFailure: error => Effect.flatMap(parseFailure(error), Effect.fail),
      onSuccess: parseSuccess
    });
  };
  return identity({
    id: backing.id,
    execute: execute,
    executeEffect: executeEffect
  });
});
/** @internal */
export const makePoolSerialized = options => Effect.gen(function* () {
  const manager = yield* WorkerManager;
  const workers = new Set();
  const acquire = pipe(makeSerialized(options), Effect.tap(worker => Effect.sync(() => workers.add(worker))), Effect.tap(worker => Effect.addFinalizer(() => Effect.sync(() => workers.delete(worker)))), options.onCreate ? Effect.tap(options.onCreate) : identity, Effect.provideService(WorkerManager, manager));
  const backing = yield* "timeToLive" in options ? Pool.makeWithTTL({
    acquire,
    min: options.minSize,
    max: options.maxSize,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization,
    timeToLive: options.timeToLive
  }) : Pool.make({
    acquire,
    size: options.size,
    concurrency: options.concurrency,
    targetUtilization: options.targetUtilization
  });
  const pool = {
    backing,
    broadcast: message => Effect.forEach(workers, worker => worker.executeEffect(message), {
      concurrency: "unbounded",
      discard: true
    }),
    execute: message => Stream.unwrapScoped(Effect.map(backing.get, worker => worker.execute(message))),
    executeEffect: message => Effect.scoped(Effect.flatMap(backing.get, worker => worker.executeEffect(message)))
  };
  // report any spawn errors
  yield* Effect.scoped(backing.get);
  return pool;
});
/** @internal */
export const makePoolSerializedLayer = (tag, options) => Layer.scoped(tag, makePoolSerialized(options));
/** @internal */
export const layerSpawner = spawner => Layer.succeed(Spawner, spawner);
//# sourceMappingURL=worker.js.map