import * as Worker from "@effect/platform/Worker";
import { WorkerError } from "@effect/platform/WorkerError";
import * as Effect from "effect/Effect";
import { pipe } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Queue from "effect/Queue";
const platformWorkerImpl = /*#__PURE__*/Worker.PlatformWorker.of({
  [Worker.PlatformWorkerTypeId]: Worker.PlatformWorkerTypeId,
  spawn(worker_) {
    return Effect.gen(function* (_) {
      const worker = worker_;
      yield* _(Effect.addFinalizer(() => pipe(Effect.async(resume => {
        worker.once("exit", () => {
          resume(Effect.void);
        });
        worker.postMessage([1]);
      }), Effect.timeout(5000), Effect.orElse(() => Effect.sync(() => worker.terminate())))));
      const queue = yield* _(Queue.unbounded());
      yield* _(Effect.addFinalizer(() => Queue.shutdown(queue)));
      const fiber = yield* _(Effect.async(resume => {
        worker.on("message", message => {
          queue.unsafeOffer(message);
        });
        worker.on("messageerror", error => {
          resume(new WorkerError({
            reason: "decode",
            error
          }));
        });
        worker.on("error", error => {
          resume(new WorkerError({
            reason: "unknown",
            error
          }));
        });
        worker.on("exit", code => {
          resume(new WorkerError({
            reason: "unknown",
            error: new Error(`exited with code ${code}`)
          }));
        });
      }), Effect.interruptible, Effect.forkScoped);
      const send = (message, transfers) => Effect.try({
        try: () => worker.postMessage([0, message], transfers),
        catch: error => new WorkerError({
          reason: "send",
          error
        })
      });
      return {
        fiber,
        queue,
        send
      };
    });
  }
});
/** @internal */
export const layerWorker = /*#__PURE__*/Layer.succeed(Worker.PlatformWorker, platformWorkerImpl);
/** @internal */
export const layerManager = /*#__PURE__*/Layer.provide(Worker.layerManager, layerWorker);
/** @internal */
export const layer = spawn => Layer.merge(layerManager, Worker.layerSpawner(spawn));
//# sourceMappingURL=worker.js.map