import { WorkerError } from "@effect/platform/WorkerError";
import * as Runner from "@effect/platform/WorkerRunner";
import * as Cause from "effect/Cause";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Queue from "effect/Queue";
import * as Schedule from "effect/Schedule";
import * as WorkerThreads from "node:worker_threads";
const platformRunnerImpl = /*#__PURE__*/Runner.PlatformRunner.of({
  [Runner.PlatformRunnerTypeId]: Runner.PlatformRunnerTypeId,
  start(shutdown) {
    return Effect.gen(function* (_) {
      if (!WorkerThreads.parentPort) {
        return yield* _(new WorkerError({
          reason: "spawn",
          error: new Error("not in worker")
        }));
      }
      const port = WorkerThreads.parentPort;
      const queue = yield* _(Queue.unbounded());
      yield* _(Effect.async(resume => {
        port.on("message", message => {
          if (message[0] === 0) {
            queue.unsafeOffer([0, message[1]]);
          } else {
            Effect.runFork(shutdown);
          }
        });
        port.on("messageerror", error => {
          resume(new WorkerError({
            reason: "decode",
            error
          }));
        });
        port.on("error", error => {
          resume(new WorkerError({
            reason: "unknown",
            error
          }));
        });
      }), Effect.tapErrorCause(cause => Cause.isInterruptedOnly(cause) ? Effect.void : Effect.logDebug(cause)), Effect.retry(Schedule.forever), Effect.annotateLogs({
        package: "@effect/platform-node",
        module: "WorkerRunner"
      }), Effect.interruptible, Effect.forkScoped);
      const send = (_portId, message, transfers) => Effect.sync(() => port.postMessage([1, message], transfers));
      // ready
      port.postMessage([0]);
      return {
        queue,
        send
      };
    });
  }
});
/** @internal */
export const layer = /*#__PURE__*/Layer.succeed(Runner.PlatformRunner, platformRunnerImpl);
//# sourceMappingURL=workerRunner.js.map