"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stream = exports.schemaHeaders = exports.request = exports.provideServiceEffect = exports.provideService = exports.isRpc = exports.effect = exports.currentHeaders = exports.call = exports.annotateHeaders = exports.TypeId = exports.StreamRequestTypeId = exports.StreamRequest = exports.RequestSchema = void 0;
var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
var Schema = _interopRequireWildcard(require("@effect/schema/Schema"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
var _Function = require("effect/Function");
var _GlobalValue = require("effect/GlobalValue");
var _Pipeable = require("effect/Pipeable");
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var Internal = _interopRequireWildcard(require("./internal/rpc.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category type ids
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Rpc");
/**
 * @since 1.0.0
 * @category refinements
 */
const isRpc = u => Predicate.hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.isRpc = isRpc;
const effect = (schema, handler) => ({
  [TypeId]: TypeId,
  _tag: "Effect",
  schema,
  handler,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
});
/**
 * @since 1.0.0
 * @category type ids
 */
exports.effect = effect;
const StreamRequestTypeId = exports.StreamRequestTypeId = Internal.StreamRequestTypeId;
/**
 * @since 1.0.0
 * @category schemas
 */
const StreamRequest = () => (tag, failure, success, fields) => {
  return class extends Schema.TaggedRequest()(tag, failure, success, fields) {
    constructor(props, disableValidation) {
      super(props, disableValidation);
      this[Internal.StreamRequestTypeId] = Internal.StreamRequestTypeId;
    }
  };
};
/**
 * @since 1.0.0
 * @category constructors
 */
exports.StreamRequest = StreamRequest;
const stream = (schema, handler) => ({
  [TypeId]: TypeId,
  _tag: "Stream",
  schema: schema,
  handler,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
});
/**
 * @since 1.0.0
 * @category schemas
 */
exports.stream = stream;
const RequestSchema = schema => Schema.Struct({
  request: schema,
  traceId: Schema.String,
  spanId: Schema.String,
  sampled: Schema.Boolean,
  headers: Schema.Record(Schema.String, Schema.String)
});
/**
 * @since 1.0.0
 * @category headers
 */
exports.RequestSchema = RequestSchema;
const currentHeaders = exports.currentHeaders = /*#__PURE__*/(0, _GlobalValue.globalValue)("@effect/rpc/Rpc/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
/**
 * @since 1.0.0
 * @category headers
 */
const annotateHeaders = exports.annotateHeaders = /*#__PURE__*/(0, _Function.dual)(2, (self, headers) => {
  const resolved = Headers.fromInput(headers);
  return Effect.locallyWith(self, currentHeaders, prev => ({
    ...prev,
    ...resolved
  }));
});
/**
 * @since 1.0.0
 * @category headers
 */
const schemaHeaders = schema => {
  const decode = Schema.decodeUnknown(schema);
  return Effect.flatMap(FiberRef.get(currentHeaders), decode);
};
/**
 * @since 1.0.0
 * @category requests
 */
exports.schemaHeaders = schemaHeaders;
const request = (request, options) => (0, _Function.pipe)(Effect.makeSpanScoped(`${options?.spanPrefix ?? "Rpc.request "}${request._tag}`, {
  kind: "client",
  captureStackTrace: false
}), Effect.zip(FiberRef.get(currentHeaders)), Effect.map(([span, headers]) => Internal.makeRequest({
  request,
  traceId: span.traceId,
  spanId: span.spanId,
  sampled: span.sampled,
  headers
})));
/**
 * @since 1.0.0
 * @category requests
 */
exports.request = request;
const call = (req, resolver, options) => {
  const isStream = (Internal.StreamRequestTypeId in req);
  const res = (0, _Function.pipe)(request(req, options), Effect.flatMap(_ => Effect.request(_, resolver)));
  return isStream ? Stream.unwrapScoped(res) : Effect.scoped(res);
};
/**
 * @since 1.0.0
 * @category context
 */
exports.call = call;
const provideServiceEffect = exports.provideServiceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, make) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))) : stream(self.schema, req => Stream.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))));
/**
 * @since 1.0.0
 * @category context
 */
const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, service) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideService(self.handler(req), tag, service)) : stream(self.schema, req => Stream.provideService(self.handler(req), tag, service)));
//# sourceMappingURL=Rpc.js.map