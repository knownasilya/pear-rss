/**
 * @since 1.0.0
 */
import * as Headers from "@effect/platform/Headers";
import * as Schema from "@effect/schema/Schema";
import * as Effect from "effect/Effect";
import * as FiberRef from "effect/FiberRef";
import { dual, pipe } from "effect/Function";
import { globalValue } from "effect/GlobalValue";
import { pipeArguments } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as Stream from "effect/Stream";
import * as Internal from "./internal/rpc.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Rpc");
/**
 * @since 1.0.0
 * @category refinements
 */
export const isRpc = u => Predicate.hasProperty(u, TypeId);
/**
 * @since 1.0.0
 * @category constructors
 */
export const effect = (schema, handler) => ({
  [TypeId]: TypeId,
  _tag: "Effect",
  schema,
  handler,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
/**
 * @since 1.0.0
 * @category type ids
 */
export const StreamRequestTypeId = Internal.StreamRequestTypeId;
/**
 * @since 1.0.0
 * @category schemas
 */
export const StreamRequest = () => (tag, failure, success, fields) => {
  return class extends Schema.TaggedRequest()(tag, failure, success, fields) {
    constructor(props, disableValidation) {
      super(props, disableValidation);
      this[Internal.StreamRequestTypeId] = Internal.StreamRequestTypeId;
    }
  };
};
/**
 * @since 1.0.0
 * @category constructors
 */
export const stream = (schema, handler) => ({
  [TypeId]: TypeId,
  _tag: "Stream",
  schema: schema,
  handler,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
/**
 * @since 1.0.0
 * @category schemas
 */
export const RequestSchema = schema => Schema.Struct({
  request: schema,
  traceId: Schema.String,
  spanId: Schema.String,
  sampled: Schema.Boolean,
  headers: Schema.Record(Schema.String, Schema.String)
});
/**
 * @since 1.0.0
 * @category headers
 */
export const currentHeaders = /*#__PURE__*/globalValue("@effect/rpc/Rpc/currentHeaders", () => FiberRef.unsafeMake(Headers.empty));
/**
 * @since 1.0.0
 * @category headers
 */
export const annotateHeaders = /*#__PURE__*/dual(2, (self, headers) => {
  const resolved = Headers.fromInput(headers);
  return Effect.locallyWith(self, currentHeaders, prev => ({
    ...prev,
    ...resolved
  }));
});
/**
 * @since 1.0.0
 * @category headers
 */
export const schemaHeaders = schema => {
  const decode = Schema.decodeUnknown(schema);
  return Effect.flatMap(FiberRef.get(currentHeaders), decode);
};
/**
 * @since 1.0.0
 * @category requests
 */
export const request = (request, options) => pipe(Effect.makeSpanScoped(`${options?.spanPrefix ?? "Rpc.request "}${request._tag}`, {
  kind: "client",
  captureStackTrace: false
}), Effect.zip(FiberRef.get(currentHeaders)), Effect.map(([span, headers]) => Internal.makeRequest({
  request,
  traceId: span.traceId,
  spanId: span.spanId,
  sampled: span.sampled,
  headers
})));
/**
 * @since 1.0.0
 * @category requests
 */
export const call = (req, resolver, options) => {
  const isStream = (Internal.StreamRequestTypeId in req);
  const res = pipe(request(req, options), Effect.flatMap(_ => Effect.request(_, resolver)));
  return isStream ? Stream.unwrapScoped(res) : Effect.scoped(res);
};
/**
 * @since 1.0.0
 * @category context
 */
export const provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, make) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))) : stream(self.schema, req => Stream.provideServiceEffect(self.handler(req), tag, Effect.orDie(make))));
/**
 * @since 1.0.0
 * @category context
 */
export const provideService = /*#__PURE__*/dual(3, (self, tag, service) => self._tag === "Effect" ? effect(self.schema, req => Effect.provideService(self.handler(req), tag, service)) : stream(self.schema, req => Stream.provideService(self.handler(req), tag, service)));
//# sourceMappingURL=Rpc.js.map