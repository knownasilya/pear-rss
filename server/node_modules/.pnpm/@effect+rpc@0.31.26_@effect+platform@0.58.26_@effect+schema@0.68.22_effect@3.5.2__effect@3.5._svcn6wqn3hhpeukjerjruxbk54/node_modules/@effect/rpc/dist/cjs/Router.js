"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHandlerUndecoded = exports.toHandlerRaw = exports.toHandlerEffect = exports.toHandler = exports.provideServiceEffect = exports.provideService = exports.make = exports.isRouter = exports.TypeId = void 0;
var Schema = _interopRequireWildcard(require("@effect/schema/Schema"));
var Serializable = _interopRequireWildcard(require("@effect/schema/Serializable"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Channel = _interopRequireWildcard(require("effect/Channel"));
var Chunk = _interopRequireWildcard(require("effect/Chunk"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var _Function = require("effect/Function");
var _Pipeable = require("effect/Pipeable");
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var Queue = _interopRequireWildcard(require("effect/Queue"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var _rpc = require("./internal/rpc.js");
var Rpc = _interopRequireWildcard(require("./Rpc.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 1.0.0
 * @category type ids
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Router");
/**
 * @since 1.0.0
 * @category refinements
 */
const isRouter = u => Predicate.hasProperty(u, TypeId);
exports.isRouter = isRouter;
const fromSet = rpcs => ({
  [TypeId]: TypeId,
  rpcs,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
});
/**
 * @since 1.0.0
 * @category constructors
 */
const make = (...rpcs) => {
  const rpcSet = new Set();
  rpcs.forEach(rpc => {
    if (isRouter(rpc)) {
      rpc.rpcs.forEach(rpc => rpcSet.add(rpc));
    } else {
      rpcSet.add(rpc);
    }
  });
  return fromSet(rpcSet);
};
/**
 * @since 1.0.0
 * @category context
 */
exports.make = make;
const provideServiceEffect = exports.provideServiceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, effect) => fromSet(new Set([...self.rpcs].map(Rpc.provideServiceEffect(tag, effect)))));
/**
 * @since 1.0.0
 * @category context
 */
const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, service) => fromSet(new Set([...self.rpcs].map(Rpc.provideService(tag, service)))));
const EOF = /*#__PURE__*/Symbol.for("@effect/rpc/Router/EOF");
const channelFromQueue = queue => {
  const loop = Channel.flatMap(Queue.takeBetween(queue, 1, Number.MAX_SAFE_INTEGER), chunk => {
    if (Chunk.unsafeLast(chunk) === EOF) {
      return Channel.write(Chunk.dropRight(chunk, 1));
    }
    return Channel.zipRight(Channel.write(chunk), loop);
  });
  return loop;
};
const emptyExit = /*#__PURE__*/Schema.encodeSync(Schema.Exit({
  failure: Schema.Never,
  success: Schema.Never
}))( /*#__PURE__*/Exit.failCause(Cause.empty));
/**
 * @since 1.0.0
 * @category combinators
 */
const toHandler = (router, options) => {
  const spanPrefix = options?.spanPrefix ?? "Rpc.router ";
  const schema = Schema.Union(...[...router.rpcs].map(rpc => Schema.transform(rpc.schema, Schema.typeSchema(Schema.Tuple(rpc.schema, Schema.Any)), {
    strict: true,
    decode: request => [request, rpc],
    encode: ([request]) => request
  })));
  const schemaArray = Schema.Array(Rpc.RequestSchema(schema));
  const decode = Schema.decodeUnknown(schemaArray);
  const getEncode = (0, _rpc.withRequestTag)(req => Schema.encode(Serializable.exitSchema(req)));
  const getEncodeChunk = (0, _rpc.withRequestTag)(req => Schema.encode(Schema.Chunk(Serializable.exitSchema(req))));
  return u => (0, _Function.pipe)(decode(u), Effect.zip(Queue.unbounded()), Effect.tap(([requests, queue]) => (0, _Function.pipe)(Effect.forEach(requests, (req, index) => {
    const [request, rpc] = req.request;
    if (rpc._tag === "Effect") {
      const encode = getEncode(request);
      return (0, _Function.pipe)(Effect.exit(rpc.handler(request)), Effect.flatMap(encode), Effect.orDie, Effect.matchCauseEffect({
        onSuccess: response => Queue.offer(queue, [index, response]),
        onFailure: cause => Effect.flatMap(encode(Exit.failCause(cause)), response => Queue.offer(queue, [index, response]))
      }), Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
        kind: "server",
        parent: {
          _tag: "ExternalSpan",
          traceId: req.traceId,
          spanId: req.spanId,
          sampled: req.sampled,
          context: Context.empty()
        },
        captureStackTrace: false
      }));
    }
    const encode = getEncodeChunk(request);
    return (0, _Function.pipe)(rpc.handler(request), Stream.toChannel, Channel.mapOutEffect(chunk => Effect.flatMap(encode(Chunk.map(chunk, Exit.succeed)), response => Queue.offer(queue, [index, response]))), Channel.runDrain, Effect.matchCauseEffect({
      onSuccess: () => Queue.offer(queue, [index, [emptyExit]]),
      onFailure: cause => Effect.flatMap(encode(Chunk.of(Exit.failCause(cause))), response => Queue.offer(queue, [index, response]))
    }), Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
      kind: "server",
      parent: {
        _tag: "ExternalSpan",
        traceId: req.traceId,
        spanId: req.spanId,
        sampled: req.sampled,
        context: Context.empty()
      },
      captureStackTrace: false
    }));
  }, {
    concurrency: "unbounded",
    discard: true
  }), Effect.ensuring(Queue.offer(queue, EOF)), Effect.fork)), Effect.map(([_, queue]) => Stream.fromChannel(channelFromQueue(queue))), Stream.unwrap);
};
/**
 * @since 1.0.0
 * @category combinators
 */
exports.toHandler = toHandler;
const toHandlerEffect = (router, options) => {
  const spanPrefix = options?.spanPrefix ?? "Rpc.router ";
  const schema = Schema.Union(...[...router.rpcs].map(rpc => Schema.transform(rpc.schema, Schema.typeSchema(Schema.Tuple(rpc.schema, Schema.Any)), {
    strict: true,
    decode: request => [request, rpc],
    encode: ([request]) => request
  })));
  const schemaArray = Schema.Array(Rpc.RequestSchema(schema));
  const decode = Schema.decodeUnknown(schemaArray);
  const getEncode = (0, _rpc.withRequestTag)(req => Schema.encode(Serializable.exitSchema(req)));
  const getEncodeChunk = (0, _rpc.withRequestTag)(req => Schema.encode(Schema.Chunk(Serializable.exitSchema(req))));
  return u => Effect.flatMap(decode(u), Effect.forEach(req => {
    const [request, rpc] = req.request;
    if (rpc._tag === "Effect") {
      const encode = getEncode(request);
      return (0, _Function.pipe)(Effect.exit(rpc.handler(request)), Effect.flatMap(encode), Effect.orDie, Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
        kind: "server",
        parent: {
          _tag: "ExternalSpan",
          traceId: req.traceId,
          spanId: req.spanId,
          sampled: req.sampled,
          context: Context.empty()
        },
        captureStackTrace: false
      }));
    }
    const encode = getEncodeChunk(request);
    return (0, _Function.pipe)(rpc.handler(request), Stream.map(Exit.succeed), Stream.catchAllCause(cause => Stream.succeed(Exit.failCause(cause))), Stream.runCollect, Effect.flatMap(encode), Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
      kind: "server",
      parent: {
        _tag: "ExternalSpan",
        traceId: req.traceId,
        spanId: req.spanId,
        sampled: req.sampled,
        context: Context.empty()
      },
      captureStackTrace: false
    }));
  }, {
    concurrency: "unbounded"
  }));
};
/**
 * @since 1.0.0
 * @category combinators
 */
exports.toHandlerEffect = toHandlerEffect;
const toHandlerRaw = router => {
  const schema = Schema.Union(...[...router.rpcs].map(rpc => Schema.transform(Schema.typeSchema(rpc.schema), Schema.typeSchema(Schema.Tuple(rpc.schema, Schema.Any)), {
    strict: true,
    decode: request => [request, rpc],
    encode: ([request]) => request
  })));
  const parse = Schema.decode(schema);
  return request => {
    const isStream = (_rpc.StreamRequestTypeId in request);
    const withHandler = parse(request);
    if (isStream) {
      return Stream.unwrap(Effect.map(withHandler, ([request, rpc]) => rpc.handler(request)));
    }
    return Effect.flatMap(withHandler, ([request, rpc]) => rpc.handler(request));
  };
};
/**
 * @since 1.0.0
 * @category combinators
 */
exports.toHandlerRaw = toHandlerRaw;
const toHandlerUndecoded = router => {
  const handler = toHandlerRaw(router);
  const getEncode = (0, _rpc.withRequestTag)(req => Schema.encode(Serializable.successSchema(req)));
  const getEncodeChunk = (0, _rpc.withRequestTag)(req => Schema.encode(Schema.ChunkFromSelf(Serializable.successSchema(req))));
  return request => {
    const result = handler(request);
    if (Effect.isEffect(result)) {
      const encode = getEncode(request);
      return Effect.flatMap(result, encode);
    }
    const encode = getEncodeChunk(request);
    return Stream.mapChunksEffect(result, encode);
  };
};
exports.toHandlerUndecoded = toHandlerUndecoded;
//# sourceMappingURL=Router.js.map