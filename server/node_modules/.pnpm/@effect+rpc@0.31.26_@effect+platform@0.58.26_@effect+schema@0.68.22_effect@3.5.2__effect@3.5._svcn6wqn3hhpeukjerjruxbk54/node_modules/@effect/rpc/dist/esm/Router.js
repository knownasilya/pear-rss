import * as Schema from "@effect/schema/Schema";
import * as Serializable from "@effect/schema/Serializable";
import * as Cause from "effect/Cause";
import * as Channel from "effect/Channel";
import * as Chunk from "effect/Chunk";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { dual, pipe } from "effect/Function";
import { pipeArguments } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as Queue from "effect/Queue";
import * as Stream from "effect/Stream";
import { StreamRequestTypeId, withRequestTag } from "./internal/rpc.js";
import * as Rpc from "./Rpc.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/rpc/Router");
/**
 * @since 1.0.0
 * @category refinements
 */
export const isRouter = u => Predicate.hasProperty(u, TypeId);
const fromSet = rpcs => ({
  [TypeId]: TypeId,
  rpcs,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
/**
 * @since 1.0.0
 * @category constructors
 */
export const make = (...rpcs) => {
  const rpcSet = new Set();
  rpcs.forEach(rpc => {
    if (isRouter(rpc)) {
      rpc.rpcs.forEach(rpc => rpcSet.add(rpc));
    } else {
      rpcSet.add(rpc);
    }
  });
  return fromSet(rpcSet);
};
/**
 * @since 1.0.0
 * @category context
 */
export const provideServiceEffect = /*#__PURE__*/dual(3, (self, tag, effect) => fromSet(new Set([...self.rpcs].map(Rpc.provideServiceEffect(tag, effect)))));
/**
 * @since 1.0.0
 * @category context
 */
export const provideService = /*#__PURE__*/dual(3, (self, tag, service) => fromSet(new Set([...self.rpcs].map(Rpc.provideService(tag, service)))));
const EOF = /*#__PURE__*/Symbol.for("@effect/rpc/Router/EOF");
const channelFromQueue = queue => {
  const loop = Channel.flatMap(Queue.takeBetween(queue, 1, Number.MAX_SAFE_INTEGER), chunk => {
    if (Chunk.unsafeLast(chunk) === EOF) {
      return Channel.write(Chunk.dropRight(chunk, 1));
    }
    return Channel.zipRight(Channel.write(chunk), loop);
  });
  return loop;
};
const emptyExit = /*#__PURE__*/Schema.encodeSync(Schema.Exit({
  failure: Schema.Never,
  success: Schema.Never
}))( /*#__PURE__*/Exit.failCause(Cause.empty));
/**
 * @since 1.0.0
 * @category combinators
 */
export const toHandler = (router, options) => {
  const spanPrefix = options?.spanPrefix ?? "Rpc.router ";
  const schema = Schema.Union(...[...router.rpcs].map(rpc => Schema.transform(rpc.schema, Schema.typeSchema(Schema.Tuple(rpc.schema, Schema.Any)), {
    strict: true,
    decode: request => [request, rpc],
    encode: ([request]) => request
  })));
  const schemaArray = Schema.Array(Rpc.RequestSchema(schema));
  const decode = Schema.decodeUnknown(schemaArray);
  const getEncode = withRequestTag(req => Schema.encode(Serializable.exitSchema(req)));
  const getEncodeChunk = withRequestTag(req => Schema.encode(Schema.Chunk(Serializable.exitSchema(req))));
  return u => pipe(decode(u), Effect.zip(Queue.unbounded()), Effect.tap(([requests, queue]) => pipe(Effect.forEach(requests, (req, index) => {
    const [request, rpc] = req.request;
    if (rpc._tag === "Effect") {
      const encode = getEncode(request);
      return pipe(Effect.exit(rpc.handler(request)), Effect.flatMap(encode), Effect.orDie, Effect.matchCauseEffect({
        onSuccess: response => Queue.offer(queue, [index, response]),
        onFailure: cause => Effect.flatMap(encode(Exit.failCause(cause)), response => Queue.offer(queue, [index, response]))
      }), Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
        kind: "server",
        parent: {
          _tag: "ExternalSpan",
          traceId: req.traceId,
          spanId: req.spanId,
          sampled: req.sampled,
          context: Context.empty()
        },
        captureStackTrace: false
      }));
    }
    const encode = getEncodeChunk(request);
    return pipe(rpc.handler(request), Stream.toChannel, Channel.mapOutEffect(chunk => Effect.flatMap(encode(Chunk.map(chunk, Exit.succeed)), response => Queue.offer(queue, [index, response]))), Channel.runDrain, Effect.matchCauseEffect({
      onSuccess: () => Queue.offer(queue, [index, [emptyExit]]),
      onFailure: cause => Effect.flatMap(encode(Chunk.of(Exit.failCause(cause))), response => Queue.offer(queue, [index, response]))
    }), Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
      kind: "server",
      parent: {
        _tag: "ExternalSpan",
        traceId: req.traceId,
        spanId: req.spanId,
        sampled: req.sampled,
        context: Context.empty()
      },
      captureStackTrace: false
    }));
  }, {
    concurrency: "unbounded",
    discard: true
  }), Effect.ensuring(Queue.offer(queue, EOF)), Effect.fork)), Effect.map(([_, queue]) => Stream.fromChannel(channelFromQueue(queue))), Stream.unwrap);
};
/**
 * @since 1.0.0
 * @category combinators
 */
export const toHandlerEffect = (router, options) => {
  const spanPrefix = options?.spanPrefix ?? "Rpc.router ";
  const schema = Schema.Union(...[...router.rpcs].map(rpc => Schema.transform(rpc.schema, Schema.typeSchema(Schema.Tuple(rpc.schema, Schema.Any)), {
    strict: true,
    decode: request => [request, rpc],
    encode: ([request]) => request
  })));
  const schemaArray = Schema.Array(Rpc.RequestSchema(schema));
  const decode = Schema.decodeUnknown(schemaArray);
  const getEncode = withRequestTag(req => Schema.encode(Serializable.exitSchema(req)));
  const getEncodeChunk = withRequestTag(req => Schema.encode(Schema.Chunk(Serializable.exitSchema(req))));
  return u => Effect.flatMap(decode(u), Effect.forEach(req => {
    const [request, rpc] = req.request;
    if (rpc._tag === "Effect") {
      const encode = getEncode(request);
      return pipe(Effect.exit(rpc.handler(request)), Effect.flatMap(encode), Effect.orDie, Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
        kind: "server",
        parent: {
          _tag: "ExternalSpan",
          traceId: req.traceId,
          spanId: req.spanId,
          sampled: req.sampled,
          context: Context.empty()
        },
        captureStackTrace: false
      }));
    }
    const encode = getEncodeChunk(request);
    return pipe(rpc.handler(request), Stream.map(Exit.succeed), Stream.catchAllCause(cause => Stream.succeed(Exit.failCause(cause))), Stream.runCollect, Effect.flatMap(encode), Effect.locally(Rpc.currentHeaders, req.headers), Effect.withSpan(`${spanPrefix}${request._tag}`, {
      kind: "server",
      parent: {
        _tag: "ExternalSpan",
        traceId: req.traceId,
        spanId: req.spanId,
        sampled: req.sampled,
        context: Context.empty()
      },
      captureStackTrace: false
    }));
  }, {
    concurrency: "unbounded"
  }));
};
/**
 * @since 1.0.0
 * @category combinators
 */
export const toHandlerRaw = router => {
  const schema = Schema.Union(...[...router.rpcs].map(rpc => Schema.transform(Schema.typeSchema(rpc.schema), Schema.typeSchema(Schema.Tuple(rpc.schema, Schema.Any)), {
    strict: true,
    decode: request => [request, rpc],
    encode: ([request]) => request
  })));
  const parse = Schema.decode(schema);
  return request => {
    const isStream = (StreamRequestTypeId in request);
    const withHandler = parse(request);
    if (isStream) {
      return Stream.unwrap(Effect.map(withHandler, ([request, rpc]) => rpc.handler(request)));
    }
    return Effect.flatMap(withHandler, ([request, rpc]) => rpc.handler(request));
  };
};
/**
 * @since 1.0.0
 * @category combinators
 */
export const toHandlerUndecoded = router => {
  const handler = toHandlerRaw(router);
  const getEncode = withRequestTag(req => Schema.encode(Serializable.successSchema(req)));
  const getEncodeChunk = withRequestTag(req => Schema.encode(Schema.ChunkFromSelf(Serializable.successSchema(req))));
  return request => {
    const result = handler(request);
    if (Effect.isEffect(result)) {
      const encode = getEncode(request);
      return Effect.flatMap(result, encode);
    }
    const encode = getEncodeChunk(request);
    return Stream.mapChunksEffect(result, encode);
  };
};
//# sourceMappingURL=Router.js.map