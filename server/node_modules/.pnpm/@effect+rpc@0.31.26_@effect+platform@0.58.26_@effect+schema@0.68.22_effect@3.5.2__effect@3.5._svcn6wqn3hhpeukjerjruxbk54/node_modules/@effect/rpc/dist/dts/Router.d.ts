/**
 * @since 1.0.0
 */
import type { ParseError } from "@effect/schema/ParseResult";
import * as Schema from "@effect/schema/Schema";
import * as Serializable from "@effect/schema/Serializable";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import { type Pipeable } from "effect/Pipeable";
import * as Stream from "effect/Stream";
import * as Rpc from "./Rpc.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isRouter: (u: unknown) => u is Router<any, any>;
/**
 * @since 1.0.0
 * @category models
 */
export interface Router<Reqs extends Schema.TaggedRequest.Any, R> extends Pipeable {
    readonly [TypeId]: TypeId;
    readonly rpcs: ReadonlySet<Rpc.Rpc<Reqs, R>>;
}
/**
 * @since 1.0.0
 * @category models
 */
export declare namespace Router {
    /**
     * @since 1.0.0
     * @category models
     */
    type Context<A extends Router<any, any>> = A extends Router<infer Req, infer R> ? R | Serializable.SerializableWithResult.Context<Req> : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type ContextRaw<A extends Router<any, any>> = A extends Router<infer Req, infer R> ? R | Serializable.Serializable.Context<Req> : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type Request<A extends Router<any, any>> = A extends Router<infer Req, infer _R> ? Req : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type Response = [
        index: number,
        response: Schema.ExitEncoded<any, any> | ReadonlyArray<Schema.ExitEncoded<any, any>>
    ];
    /**
     * @since 1.0.0
     * @category models
     */
    type ResponseEffect = Schema.ExitEncoded<any, any> | ReadonlyArray<Schema.ExitEncoded<any, any>>;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const make: <Rpcs extends ReadonlyArray<Rpc.Rpc<any, any> | Router<any, any>>>(...rpcs: Rpcs) => Router<Rpc.Rpc.Request<Extract<Rpcs[number], {
    readonly [Rpc.TypeId]: Rpc.TypeId;
}>> | Router.Request<Extract<Rpcs[number], {
    readonly [TypeId]: TypeId;
}>>, Rpc.Rpc.Context<Extract<Rpcs[number], {
    readonly [Rpc.TypeId]: Rpc.TypeId;
}>> | Router.Context<Extract<Rpcs[number], {
    readonly [TypeId]: TypeId;
}>>>;
/**
 * @since 1.0.0
 * @category context
 */
export declare const provideServiceEffect: {
    <I, S, E, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): <Reqs extends Schema.TaggedRequest.Any, R>(self: Router<Reqs, R>) => Router<Reqs, Exclude<R, I> | R2>;
    <Reqs extends Schema.TaggedRequest.Any, R, I, S, E, R2>(self: Router<Reqs, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): Router<Reqs, Exclude<R, I> | R2>;
};
/**
 * @since 1.0.0
 * @category context
 */
export declare const provideService: {
    <I, S>(tag: Context.Tag<I, S>, service: S): <Reqs extends Schema.TaggedRequest.Any, R>(self: Router<Reqs, R>) => Router<Reqs, Exclude<R, I>>;
    <Reqs extends Schema.TaggedRequest.Any, R, I, S>(self: Router<Reqs, R>, tag: Context.Tag<I, S>, service: S): Router<Reqs, Exclude<R, I>>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const toHandler: <R extends Router<any, any>>(router: R, options?: {
    readonly spanPrefix?: string;
}) => (u: unknown) => Stream.Stream<Router.Response, ParseError, Router.Context<R>>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const toHandlerEffect: <R extends Router<any, any>>(router: R, options?: {
    readonly spanPrefix?: string;
}) => (u: unknown) => Effect.Effect<ReadonlyArray<Router.ResponseEffect>, ParseError, Router.Context<R>>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const toHandlerRaw: <R extends Router<any, any>>(router: R) => <Req extends Router.Request<R>>(request: Req) => Rpc.Rpc.Result<Req, Router.ContextRaw<R>>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const toHandlerUndecoded: <R extends Router<any, any>>(router: R) => <Req extends Router.Request<R>>(request: Req) => Rpc.Rpc.ResultUndecoded<Req, Router.Context<R>>;
//# sourceMappingURL=Router.d.ts.map