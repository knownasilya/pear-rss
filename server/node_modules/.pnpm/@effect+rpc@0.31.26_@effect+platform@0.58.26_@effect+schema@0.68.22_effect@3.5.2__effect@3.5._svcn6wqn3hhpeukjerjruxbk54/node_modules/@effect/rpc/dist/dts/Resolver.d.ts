/**
 * @since 1.0.0
 */
import * as Headers from "@effect/platform/Headers";
import * as Schema from "@effect/schema/Schema";
import * as Serializable from "@effect/schema/Serializable";
import * as Effect from "effect/Effect";
import * as RequestResolver from "effect/RequestResolver";
import * as Stream from "effect/Stream";
import type * as Router from "./Router.js";
import * as Rpc from "./Rpc.js";
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const make: <HR, E>(handler: (u: ReadonlyArray<unknown>) => Stream.Stream<unknown, E, HR>) => <R extends Router.Router<any, any>>() => RequestResolver.RequestResolver<Rpc.Request<Router.Router.Request<R>>, Serializable.SerializableWithResult.Context<Router.Router.Request<R>> | HR>;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const annotateHeaders: {
    (headers: Headers.Input): <Req extends Schema.TaggedRequest.Any, R>(self: RequestResolver.RequestResolver<Rpc.Request<Req>, R>) => RequestResolver.RequestResolver<Rpc.Request<Req>, R>;
    <Req extends Schema.TaggedRequest.Any, R>(self: RequestResolver.RequestResolver<Rpc.Request<Req>, R>, headers: Headers.Input): RequestResolver.RequestResolver<Rpc.Request<Req>, R>;
};
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const annotateHeadersEffect: {
    <E, R2>(headers: Effect.Effect<Headers.Input, E, R2>): <Req extends Schema.TaggedRequest.Any, R>(self: RequestResolver.RequestResolver<Rpc.Request<Req>, R>) => RequestResolver.RequestResolver<Rpc.Request<Req>, R | R2>;
    <Req extends Schema.TaggedRequest.Any, R, E, R2>(self: RequestResolver.RequestResolver<Rpc.Request<Req>, R>, headers: Effect.Effect<Headers.Input, E, R2>): RequestResolver.RequestResolver<Rpc.Request<Req>, R | R2>;
};
/**
 * @since 1.0.0
 * @category models
 */
export type Client<R extends RequestResolver.RequestResolver<Rpc.Request<any>, never> | Effect.Effect<RequestResolver.RequestResolver<Rpc.Request<any>, never>, never, any>> = R extends Effect.Effect<RequestResolver.RequestResolver<Rpc.Request<infer RReq>>, infer _E, infer R> ? (<Req extends RReq>(request: Req) => Rpc.Rpc.Result<Req, R>) : R extends RequestResolver.RequestResolver<Rpc.Request<infer RReq>, never> ? (<Req extends RReq>(request: Req) => Rpc.Rpc.Result<Req>) : never;
/**
 * @since 1.0.0
 * @category combinators
 */
export declare const toClient: <R extends RequestResolver.RequestResolver<Rpc.Request<any>, never> | Effect.Effect<RequestResolver.RequestResolver<Rpc.Request<any>, never>, never, any>>(resolver: R, options?: {
    readonly spanPrefix?: string;
}) => Client<R>;
//# sourceMappingURL=Resolver.d.ts.map