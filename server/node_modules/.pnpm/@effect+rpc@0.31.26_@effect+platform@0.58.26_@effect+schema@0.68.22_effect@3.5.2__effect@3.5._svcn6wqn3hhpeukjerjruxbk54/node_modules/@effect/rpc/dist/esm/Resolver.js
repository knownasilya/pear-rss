/**
 * @since 1.0.0
 */
import * as Headers from "@effect/platform/Headers";
import * as Schema from "@effect/schema/Schema";
import * as Serializable from "@effect/schema/Serializable";
import * as Arr from "effect/Array";
import * as Cause from "effect/Cause";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { dual, pipe } from "effect/Function";
import * as Request from "effect/Request";
import * as RequestResolver from "effect/RequestResolver";
import * as Stream from "effect/Stream";
import { StreamRequestTypeId, withRequestTag } from "./internal/rpc.js";
import * as Rpc from "./Rpc.js";
/**
 * @since 1.0.0
 * @category constructors
 */
export const make = handler => () => {
  const getDecode = withRequestTag(req => Schema.decodeUnknown(Serializable.exitSchema(req)));
  const getDecodeChunk = withRequestTag(req => Schema.decodeUnknown(Schema.Chunk(Serializable.exitSchema(req))));
  return RequestResolver.makeBatched(requests => {
    const [effectRequests, streamRequests] = Arr.partition(requests, _ => StreamRequestTypeId in _.request);
    const processEffects = pipe(Effect.forEach(effectRequests, _ => Effect.map(Serializable.serialize(_.request), request => ({
      ..._,
      request
    }))), Effect.flatMap(payload => Stream.runForEach(Stream.filter(handler(payload), _ => Arr.isArray(_) && _.length === 2), ([index, response]) => {
      const request = effectRequests[index];
      return Effect.matchCauseEffect(Effect.orDie(getDecode(request.request)(response)), {
        onFailure: cause => Request.failCause(request, cause),
        onSuccess: exit => Request.complete(request, exit)
      });
    })), Effect.orDie, Effect.catchAllCause(cause => Effect.forEach(effectRequests, request => Request.failCause(request, cause), {
      discard: true
    })));
    const processStreams = pipe(Effect.forEach(streamRequests, request => {
      const decode = getDecodeChunk(request.request);
      const stream = pipe(Serializable.serialize(request.request), Effect.map(_ => ({
        ...request,
        request: _
      })), Effect.map(payload => pipe(handler([payload]), Stream.mapEffect(_ => Effect.orDie(decode(_[1]))), Stream.flattenChunks, Stream.flatMap(Exit.match({
        onFailure: cause => Cause.isEmptyType(cause) ? Stream.empty : Stream.failCause(cause),
        onSuccess: Stream.succeed
      })))), Effect.orDie, Stream.unwrap);
      return Request.succeed(request, stream);
    }, {
      discard: true
    }), Effect.catchAllCause(cause => Effect.forEach(streamRequests, request => Request.failCause(request, cause), {
      discard: true
    })));
    return Effect.zipRight(processStreams, processEffects);
  });
};
/**
 * @since 1.0.0
 * @category combinators
 */
export const annotateHeaders = /*#__PURE__*/dual(2, (self, headers) => {
  const resolved = Headers.fromInput(headers);
  return RequestResolver.makeWithEntry(requests => {
    requests.forEach(entries => entries.forEach(entry => {
      ;
      entry.request.headers = Headers.merge(entry.request.headers, resolved);
    }));
    return self.runAll(requests);
  });
});
/**
 * @since 1.0.0
 * @category combinators
 */
export const annotateHeadersEffect = /*#__PURE__*/dual(2, (self, headers) => RequestResolver.makeWithEntry(requests => headers.pipe(Effect.map(Headers.fromInput), Effect.orDie, Effect.matchCauseEffect({
  onFailure: cause => Effect.forEach(requests.flat(), entry => Request.failCause(entry.request, cause), {
    discard: true
  }),
  onSuccess: resolved => {
    requests.forEach(entries => entries.forEach(entry => {
      ;
      entry.request.headers = Headers.merge(entry.request.headers, resolved);
    }));
    return self.runAll(requests);
  }
}))));
/**
 * @since 1.0.0
 * @category combinators
 */
export const toClient = (resolver, options) => request => Rpc.call(request, resolver, options);
//# sourceMappingURL=Resolver.js.map