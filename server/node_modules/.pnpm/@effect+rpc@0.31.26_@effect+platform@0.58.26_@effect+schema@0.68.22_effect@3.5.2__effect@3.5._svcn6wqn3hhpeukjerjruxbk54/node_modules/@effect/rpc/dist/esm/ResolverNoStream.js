/**
 * @since 1.0.0
 */
import * as Schema from "@effect/schema/Schema";
import * as Serializable from "@effect/schema/Serializable";
import * as Channel from "effect/Channel";
import * as Chunk from "effect/Chunk";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import { pipe } from "effect/Function";
import * as Request from "effect/Request";
import * as RequestResolver from "effect/RequestResolver";
import * as Stream from "effect/Stream";
import { StreamRequestTypeId, withRequestTag } from "./internal/rpc.js";
/**
 * @since 1.0.0
 * @category constructors
 */
export const make = handler => () => {
  const getDecode = withRequestTag(req => Schema.decodeUnknown(Serializable.exitSchema(req)));
  const getDecodeChunk = withRequestTag(req => Schema.decodeUnknown(Schema.Chunk(Serializable.exitSchema(req))));
  return RequestResolver.makeBatched(requests => pipe(Effect.forEach(requests, _ => Effect.map(Serializable.serialize(_.request), request => ({
    ..._,
    request
  }))), Effect.flatMap(handler), Effect.filterOrDieMessage(_ => Array.isArray(_) && _.length === requests.length, "@effect/rpc: handler must return an array of responses with the same length as the requests."), Effect.flatMap(Effect.forEach((response, index) => {
    const request = requests[index];
    if (StreamRequestTypeId in request.request) {
      return pipe(getDecodeChunk(request.request)(response), Effect.orDie, Effect.matchCauseEffect({
        onFailure: cause => Request.succeed(request, Stream.failCause(cause)),
        onSuccess: chunk => {
          const lastExit = Chunk.unsafeLast(chunk);
          const channel = Exit.match(lastExit, {
            onFailure: cause => chunk.length > 1 ? Channel.zipRight(Channel.write(Chunk.map(Chunk.dropRight(chunk, 1), exit => exit.value)), Channel.failCause(cause)) : Channel.failCause(cause),
            onSuccess: _ => Channel.write(Chunk.map(chunk, exit => exit.value))
          });
          return Request.succeed(request, Stream.fromChannel(channel));
        }
      }));
    }
    return Effect.matchCauseEffect(Effect.orDie(getDecode(request.request)(response)), {
      onFailure: cause => Request.failCause(request, cause),
      onSuccess: exit => Request.complete(request, exit)
    });
  }, {
    discard: true
  })), Effect.orDie, Effect.catchAllCause(cause => Effect.forEach(requests, request => Request.failCause(request, cause), {
    discard: true
  }))));
};
//# sourceMappingURL=ResolverNoStream.js.map