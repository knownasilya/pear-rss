"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toClient = exports.make = exports.annotateHeadersEffect = exports.annotateHeaders = void 0;
var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
var Schema = _interopRequireWildcard(require("@effect/schema/Schema"));
var Serializable = _interopRequireWildcard(require("@effect/schema/Serializable"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var _Function = require("effect/Function");
var Request = _interopRequireWildcard(require("effect/Request"));
var RequestResolver = _interopRequireWildcard(require("effect/RequestResolver"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var _rpc = require("./internal/rpc.js");
var Rpc = _interopRequireWildcard(require("./Rpc.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category constructors
 */
const make = handler => () => {
  const getDecode = (0, _rpc.withRequestTag)(req => Schema.decodeUnknown(Serializable.exitSchema(req)));
  const getDecodeChunk = (0, _rpc.withRequestTag)(req => Schema.decodeUnknown(Schema.Chunk(Serializable.exitSchema(req))));
  return RequestResolver.makeBatched(requests => {
    const [effectRequests, streamRequests] = Arr.partition(requests, _ => _rpc.StreamRequestTypeId in _.request);
    const processEffects = (0, _Function.pipe)(Effect.forEach(effectRequests, _ => Effect.map(Serializable.serialize(_.request), request => ({
      ..._,
      request
    }))), Effect.flatMap(payload => Stream.runForEach(Stream.filter(handler(payload), _ => Arr.isArray(_) && _.length === 2), ([index, response]) => {
      const request = effectRequests[index];
      return Effect.matchCauseEffect(Effect.orDie(getDecode(request.request)(response)), {
        onFailure: cause => Request.failCause(request, cause),
        onSuccess: exit => Request.complete(request, exit)
      });
    })), Effect.orDie, Effect.catchAllCause(cause => Effect.forEach(effectRequests, request => Request.failCause(request, cause), {
      discard: true
    })));
    const processStreams = (0, _Function.pipe)(Effect.forEach(streamRequests, request => {
      const decode = getDecodeChunk(request.request);
      const stream = (0, _Function.pipe)(Serializable.serialize(request.request), Effect.map(_ => ({
        ...request,
        request: _
      })), Effect.map(payload => (0, _Function.pipe)(handler([payload]), Stream.mapEffect(_ => Effect.orDie(decode(_[1]))), Stream.flattenChunks, Stream.flatMap(Exit.match({
        onFailure: cause => Cause.isEmptyType(cause) ? Stream.empty : Stream.failCause(cause),
        onSuccess: Stream.succeed
      })))), Effect.orDie, Stream.unwrap);
      return Request.succeed(request, stream);
    }, {
      discard: true
    }), Effect.catchAllCause(cause => Effect.forEach(streamRequests, request => Request.failCause(request, cause), {
      discard: true
    })));
    return Effect.zipRight(processStreams, processEffects);
  });
};
/**
 * @since 1.0.0
 * @category combinators
 */
exports.make = make;
const annotateHeaders = exports.annotateHeaders = /*#__PURE__*/(0, _Function.dual)(2, (self, headers) => {
  const resolved = Headers.fromInput(headers);
  return RequestResolver.makeWithEntry(requests => {
    requests.forEach(entries => entries.forEach(entry => {
      ;
      entry.request.headers = Headers.merge(entry.request.headers, resolved);
    }));
    return self.runAll(requests);
  });
});
/**
 * @since 1.0.0
 * @category combinators
 */
const annotateHeadersEffect = exports.annotateHeadersEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, headers) => RequestResolver.makeWithEntry(requests => headers.pipe(Effect.map(Headers.fromInput), Effect.orDie, Effect.matchCauseEffect({
  onFailure: cause => Effect.forEach(requests.flat(), entry => Request.failCause(entry.request, cause), {
    discard: true
  }),
  onSuccess: resolved => {
    requests.forEach(entries => entries.forEach(entry => {
      ;
      entry.request.headers = Headers.merge(entry.request.headers, resolved);
    }));
    return self.runAll(requests);
  }
}))));
/**
 * @since 1.0.0
 * @category combinators
 */
const toClient = (resolver, options) => request => Rpc.call(request, resolver, options);
exports.toClient = toClient;
//# sourceMappingURL=Resolver.js.map