"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = void 0;
var Schema = _interopRequireWildcard(require("@effect/schema/Schema"));
var Serializable = _interopRequireWildcard(require("@effect/schema/Serializable"));
var Channel = _interopRequireWildcard(require("effect/Channel"));
var Chunk = _interopRequireWildcard(require("effect/Chunk"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var _Function = require("effect/Function");
var Request = _interopRequireWildcard(require("effect/Request"));
var RequestResolver = _interopRequireWildcard(require("effect/RequestResolver"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var _rpc = require("./internal/rpc.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category constructors
 */
const make = handler => () => {
  const getDecode = (0, _rpc.withRequestTag)(req => Schema.decodeUnknown(Serializable.exitSchema(req)));
  const getDecodeChunk = (0, _rpc.withRequestTag)(req => Schema.decodeUnknown(Schema.Chunk(Serializable.exitSchema(req))));
  return RequestResolver.makeBatched(requests => (0, _Function.pipe)(Effect.forEach(requests, _ => Effect.map(Serializable.serialize(_.request), request => ({
    ..._,
    request
  }))), Effect.flatMap(handler), Effect.filterOrDieMessage(_ => Array.isArray(_) && _.length === requests.length, "@effect/rpc: handler must return an array of responses with the same length as the requests."), Effect.flatMap(Effect.forEach((response, index) => {
    const request = requests[index];
    if (_rpc.StreamRequestTypeId in request.request) {
      return (0, _Function.pipe)(getDecodeChunk(request.request)(response), Effect.orDie, Effect.matchCauseEffect({
        onFailure: cause => Request.succeed(request, Stream.failCause(cause)),
        onSuccess: chunk => {
          const lastExit = Chunk.unsafeLast(chunk);
          const channel = Exit.match(lastExit, {
            onFailure: cause => chunk.length > 1 ? Channel.zipRight(Channel.write(Chunk.map(Chunk.dropRight(chunk, 1), exit => exit.value)), Channel.failCause(cause)) : Channel.failCause(cause),
            onSuccess: _ => Channel.write(Chunk.map(chunk, exit => exit.value))
          });
          return Request.succeed(request, Stream.fromChannel(channel));
        }
      }));
    }
    return Effect.matchCauseEffect(Effect.orDie(getDecode(request.request)(response)), {
      onFailure: cause => Request.failCause(request, cause),
      onSuccess: exit => Request.complete(request, exit)
    });
  }, {
    discard: true
  })), Effect.orDie, Effect.catchAllCause(cause => Effect.forEach(requests, request => Request.failCause(request, cause), {
    discard: true
  }))));
};
exports.make = make;
//# sourceMappingURL=ResolverNoStream.js.map