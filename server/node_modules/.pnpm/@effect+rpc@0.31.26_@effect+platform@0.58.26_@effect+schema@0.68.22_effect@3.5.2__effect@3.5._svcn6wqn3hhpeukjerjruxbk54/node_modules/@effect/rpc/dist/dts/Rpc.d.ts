/**
 * @since 1.0.0
 */
import * as Headers from "@effect/platform/Headers";
import type * as ParseResult from "@effect/schema/ParseResult";
import * as Schema from "@effect/schema/Schema";
import type * as Serializable from "@effect/schema/Serializable";
import type * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as FiberRef from "effect/FiberRef";
import { type Pipeable } from "effect/Pipeable";
import type * as PrimaryKey from "effect/PrimaryKey";
import type * as Record from "effect/Record";
import type * as EffectRequest from "effect/Request";
import type * as RequestResolver from "effect/RequestResolver";
import type { Scope } from "effect/Scope";
import * as Stream from "effect/Stream";
import type * as Types from "effect/Types";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category refinements
 */
export declare const isRpc: (u: unknown) => u is Rpc<any, any>;
/**
 * @since 1.0.0
 * @category models
 */
export type Rpc<Req extends Schema.TaggedRequest.Any, R> = RpcEffect<Req, R> | RpcStream<Req, R>;
/**
 * @since 1.0.0
 * @category models
 */
export interface RpcEffect<Req extends Schema.TaggedRequest.Any, R> extends Rpc.Proto<Req> {
    readonly _tag: "Effect";
    readonly handler: (request: Req) => Effect.Effect<EffectRequest.Request.Success<Req>, EffectRequest.Request.Error<Req>, R>;
}
/**
 * @since 1.0.0
 * @category models
 */
export interface RpcStream<Req extends Schema.TaggedRequest.Any, R> extends Rpc.Proto<Req> {
    readonly _tag: "Stream";
    readonly handler: (request: Req) => Stream.Stream<Req extends Serializable.WithResult<infer A, infer _I, infer _E, infer _EI, infer _R> ? A : never, Req extends Serializable.WithResult<infer _A, infer _I, infer E, infer _EI, infer _R> ? E : never, R>;
}
/**
 * @since 1.0.0
 * @category models
 */
export declare namespace Rpc {
    /**
     * @since 1.0.0
     * @category models
     */
    interface Proto<Req extends Schema.TaggedRequest.Any> extends Pipeable {
        readonly [TypeId]: TypeId;
        readonly _tag: string;
        readonly schema: Schema.Schema<Req, any, unknown>;
    }
    /**
     * @since 1.0.0
     * @category models
     */
    type Context<A extends Rpc<any, any>> = A extends Rpc<infer Req, infer R> ? R | Serializable.SerializableWithResult.Context<Req> : never;
    /**
     * @since 1.0.0
     * @category models
     */
    type Request<A extends Rpc<any, any>> = Schema.Schema.Type<A["schema"]>;
    /**
     * @since 1.0.0
     * @category models
     */
    type Result<A extends Schema.TaggedRequest.Any, R = never> = StreamRequestTypeId extends keyof A ? EffectRequest.Request.Success<A> : Effect.Effect<EffectRequest.Request.Success<A>, EffectRequest.Request.Error<A>, R>;
    /**
     * @since 1.0.0
     * @category models
     */
    type ResultUndecoded<A extends Schema.TaggedRequest.Any, R = never> = A extends Serializable.WithResult<infer _A, infer I, infer E, infer _EI, infer _R> ? StreamRequestTypeId extends keyof A ? Stream.Stream<I, E, R> : Effect.Effect<I, E, R> : never;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const effect: <Req extends Schema.TaggedRequest.Any, R>(schema: Schema.Schema<Req, any, unknown>, handler: (request: Req) => Effect.Effect<EffectRequest.Request.Success<Req>, EffectRequest.Request.Error<Req>, R>) => Rpc<Req, R>;
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const StreamRequestTypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type StreamRequestTypeId = typeof StreamRequestTypeId;
/**
 * @since 1.0.0
 * @category schemas
 */
export interface StreamRequest<Tag extends string, SR, SI, S, RR, EI, E, AI, A> extends EffectRequest.Request<Stream.Stream<A, E, never>>, Serializable.SerializableWithResult<S, SI, SR, A, AI, E, EI, RR> {
    readonly [StreamRequestTypeId]: StreamRequestTypeId;
    readonly _tag: Tag;
}
/**
 * @since 1.0.0
 * @category schemas
 */
export declare namespace StreamRequest {
    /**
     * @since 1.0.0
     * @category schemas
     */
    type Any = StreamRequest<string, any, any, any, any, any, any, any, any> | StreamRequest<string, any, any, any, any, never, never, any, any>;
}
/**
 * @since 1.0.0
 * @category schemas
 */
export interface StreamRequestConstructor<Tag extends string, Self, R, IS, S, RR, IE, E, IA, A> extends Schema.Schema<Self, Types.Simplify<IS & {
    readonly _tag: Tag;
}>, R> {
    new (props: Types.Equals<S, {}> extends true ? void : S, disableValidation?: boolean): StreamRequest<Tag, R, IS & {
        readonly _tag: Tag;
    }, Self, RR, IE, E, IA, A> & S;
}
/**
 * @since 1.0.0
 * @category schemas
 */
export declare const StreamRequest: <Self>() => <Tag extends string, E, IE, RE, A, IA, RA, Fields extends Schema.Struct.Fields>(tag: Tag, failure: Schema.Schema<E, IE, RE>, success: Schema.Schema<A, IA, RA>, fields: Fields) => StreamRequestConstructor<Tag, Self, Schema.Schema.Context<Fields[keyof Fields]>, Types.Simplify<Schema.Struct.Encoded<Fields>>, Types.Simplify<Schema.Struct.Type<Fields>>, RE | RA, IE, E, IA, A>;
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const stream: <Req extends StreamRequest.Any, R>(schema: Schema.Schema<Req, any, unknown>, handler: (request: Req) => Stream.Stream<Req extends Serializable.WithResult<infer A, infer _I, infer _E, infer _EI, infer _R> ? A : never, Req extends Serializable.WithResult<infer _A, infer _I_1, infer E, infer _EI_1, infer _R_1> ? E : never, R>) => Rpc<Req, R>;
/**
 * @since 1.0.0
 * @category models
 */
export interface Request<A extends Schema.TaggedRequest.Any> extends EffectRequest.Request<EffectRequest.Request.Success<A>, EffectRequest.Request.Error<A>>, PrimaryKey.PrimaryKey, Serializable.WithResult<Serializable.WithResult.Context<A>, Schema.Schema.Encoded<A[typeof Serializable.symbolResult]["Failure"]>, Schema.Schema.Type<A[typeof Serializable.symbolResult]["Failure"]>, Schema.Schema.Encoded<A[typeof Serializable.symbolResult]["Success"]>, Schema.Schema.Type<A[typeof Serializable.symbolResult]["Success"]>> {
    readonly request: A;
    readonly traceId: string;
    readonly spanId: string;
    readonly sampled: boolean;
    readonly headers: Headers.Headers;
}
/**
 * @since 1.0.0
 * @category models
 */
export interface RequestFrom<A> {
    readonly request: A;
    readonly traceId: string;
    readonly spanId: string;
    readonly sampled: boolean;
    readonly headers: Record<string, string>;
}
/**
 * @since 1.0.0
 * @category schemas
 */
export declare const RequestSchema: <A, I, R>(schema: Schema.Schema<A, I, R>) => Schema.Schema<RequestFrom<A>, RequestFrom<I>, R>;
/**
 * @since 1.0.0
 * @category headers
 */
export declare const currentHeaders: FiberRef.FiberRef<Headers.Headers>;
/**
 * @since 1.0.0
 * @category headers
 */
export declare const annotateHeaders: {
    (headers: Headers.Input): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
    <A, E, R>(self: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>;
};
/**
 * @since 1.0.0
 * @category headers
 */
export declare const schemaHeaders: <R, I extends Record.ReadonlyRecord<string, string | undefined>, A>(schema: Schema.Schema<R, I, A>) => Effect.Effect<R, ParseResult.ParseError, A>;
/**
 * @since 1.0.0
 * @category requests
 */
export declare const request: <A extends Schema.TaggedRequest.Any>(request: A, options?: {
    readonly spanPrefix?: string;
}) => Effect.Effect<Request<A>, never, Scope>;
/**
 * @since 1.0.0
 * @category requests
 */
export declare const call: <A extends Schema.TaggedRequest.Any, R extends RequestResolver.RequestResolver<Request<A>> | Effect.Effect<RequestResolver.RequestResolver<Request<A>>, never, any>>(req: A, resolver: R, options?: {
    readonly spanPrefix?: string;
}) => R extends Effect.Effect<infer _A, infer _E, infer R_1> ? Rpc.Result<A, R_1> : Rpc.Result<A>;
/**
 * @since 1.0.0
 * @category context
 */
export declare const provideServiceEffect: {
    <I, S, E, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): <Req extends Schema.TaggedRequest.Any, R>(self: Rpc<Req, R>) => Rpc<Req, Exclude<R, I> | R2>;
    <Req extends Schema.TaggedRequest.Any, R, I, S, E, R2>(self: Rpc<Req, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<S, E, R2>): Rpc<Req, Exclude<R, I> | R2>;
};
/**
 * @since 1.0.0
 * @category context
 */
export declare const provideService: {
    <I, S>(tag: Context.Tag<I, S>, service: S): <Req extends Schema.TaggedRequest.Any, R>(self: Rpc<Req, R>) => Rpc<Req, Exclude<R, I>>;
    <Req extends Schema.TaggedRequest.Any, R, I, S>(self: Rpc<Req, R>, tag: Context.Tag<I, S>, service: S): Rpc<Req, Exclude<R, I>>;
};
//# sourceMappingURL=Rpc.d.ts.map